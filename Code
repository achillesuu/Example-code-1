-- Variables
local Players = game:GetService("Players")
local ServerStorage = game:GetService("ServerStorage")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")

local Maps = ServerStorage:WaitForChild("Maps")
local Remotes = ReplicatedStorage:WaitForChild("Remotes")
local VoteUpdate = Remotes:WaitForChild("VoteUpdate")
local StartRound = Remotes:WaitForChild("StartRound")
local EndRound = Remotes:WaitForChild("EndRound")
local RoundTimeUpdate = Remotes:WaitForChild("RoundTimeUpdate")
local RoundResults = Remotes:WaitForChild("RoundResults")
local WaitingForPlayers = Remotes:WaitForChild("WaitingForPlayers")

local musicsFolder = game.SoundService:FindFirstChild("Musics")

local sun = musicsFolder and musicsFolder:FindFirstChild("Sun")
local hanabi = musicsFolder and musicsFolder:FindFirstChild("Hanabi")
local profundoMarAzul = musicsFolder and musicsFolder:FindFirstChild("ProfundoMarAzul")

local votes = {Supermarket = 0, Warehouse = 0}
local playerVotes = {}

local votingTime = 30
local roundTime = 120

local lobby = Workspace:WaitForChild("Lobby")
local superPad = lobby:WaitForChild("SupermarketPad")
local warePad = lobby:WaitForChild("WarehousePad")
local lobbySpawn = lobby:WaitForChild("SpawnLocation")

-- Utility: get active players (non afk)
local function getActivePlayers()
	local list = {}
	for _, p in ipairs(Players:GetPlayers()) do
		local afk = p:FindFirstChild("AFK")
		-- also ensure they have character and HumanoidRootPart (optional)
		local char = p.Character
		local hrp = char and char:FindFirstChild("HumanoidRootPart")
		if afk and afk.Value == false and hrp then
			table.insert(list, p)
		end
	end
	return list
end

local function allPlayersReady(minPlayers)
	local activePlayers = getActivePlayers()
	return #activePlayers >= minPlayers
end

-- Remove a player's vote (used on leave or AFK)
local function removePlayerVote(player)
	local userId = player.UserId
	local prev = playerVotes[userId]
	if prev then
		playerVotes[userId] = nil
		if votes[prev] then
			votes[prev] = math.max(0, votes[prev] - 1)
		end
		VoteUpdate:FireAllClients(votes, votingTime)
	end
end

-- Map voting pads handler (only registers votes if player is active)
local function onPadTouched(mapName, hit)
	local player = Players:GetPlayerFromCharacter(hit.Parent)
	if not player then return end

	local afk = player:FindFirstChild("AFK")
	if afk and afk.Value then
		return -- ignore AFK players
	end

	local userId = player.UserId
	local previousVote = playerVotes[userId]

	-- If they change vote, decrement previous
	if previousVote and previousVote ~= mapName then
		if votes[previousVote] and votes[previousVote] > 0 then
			votes[previousVote] -= 1
		end
	end

	-- If they are re-pressing same pad, do nothing
	if previousVote == mapName then return end

	playerVotes[userId] = mapName
	votes[mapName] = (votes[mapName] or 0) + 1

	VoteUpdate:FireAllClients(votes, votingTime)
end

-- Hook pads
superPad.Touched:Connect(function(hit) onPadTouched("Supermarket", hit) end)
warePad.Touched:Connect(function(hit) onPadTouched("Warehouse", hit) end)

-- Teleport helpers
local function teleportPlayersToMap(mapModel)
	local spawnsFolder = mapModel:WaitForChild("Spawns")
	local spawnPoints = spawnsFolder:GetChildren()
	local index = 1

	for _, player in ipairs(getActivePlayers()) do
		local char = player.Character
		if char and char:FindFirstChild("HumanoidRootPart") then
			local spawn = spawnPoints[index] or spawnPoints[#spawnPoints]
			char.HumanoidRootPart.CFrame = spawn.CFrame + Vector3.new(0,3,0)
			index += 1
		end
	end
end

local function teleportPlayersToLobby()
	for _, player in ipairs(getActivePlayers()) do
		local char = player.Character
		if char and char:FindFirstChild("HumanoidRootPart") then
			char.HumanoidRootPart.CFrame = lobbySpawn.CFrame + Vector3.new(0,3,0)
		end
	end
end

-- UI waiting
local function updateWaitingUI()
	local needed = math.max(0, 2 - #getActivePlayers())
	WaitingForPlayers:FireAllClients(needed)
end

-- AFK listener
local function connectAFKListener(player)
	local afk = player:WaitForChild("AFK")
	afk.Changed:Connect(function()
		-- If player went AFK, remove vote and update UI
		if afk.Value then
			removePlayerVote(player)
		end
		updateWaitingUI()
	end)
end

-- Hook existing players
for _, p in ipairs(Players:GetPlayers()) do
	connectAFKListener(p)
end

-- Player join/leave
Players.PlayerAdded:Connect(function(p)
	connectAFKListener(p)
	updateWaitingUI()
end)

Players.PlayerRemoving:Connect(function(p)
	-- Remove their vote if any
	removePlayerVote(p)
	updateWaitingUI()
end)

-- Helper: clean up active map safely
local function cleanupActiveMap()
	local activeMap = Workspace:FindFirstChild("ActiveMap")
	if activeMap then
		activeMap:Destroy()
	end
end

-- Helper: end the round early and teleport players to lobby (safe)
local function endRoundEarly()
	-- notify clients that round ended with no winner (or nil)
	EndRound:FireAllClients()
	cleanupActiveMap()
	teleportPlayersToLobby()
	-- optionally reset votes/player states if needed
end

-- Main loop
task.spawn(function()
	while true do
		-- Wait for at least 2 active players
		while not allPlayersReady(2) do
			updateWaitingUI()
			task.wait(1)
		end

		WaitingForPlayers:FireAllClients(0)

		-- Reset votes
		votes.Supermarket = 0
		votes.Warehouse = 0
		playerVotes = {}

		-- Voting phase (pauses if not enough active players)
		local remaining = votingTime
		while remaining > 0 do
			-- If at any point active players drop below 2, pause voting and wait until they're back
			if not allPlayersReady(2) then
				WaitingForPlayers:FireAllClients(math.max(0, 2 - #getActivePlayers()))
				repeat task.wait(1) until allPlayersReady(2)
				-- once back, continue voting (do not reset remaining unless you want to)
			end

			VoteUpdate:FireAllClients(votes, remaining)
			task.wait(1)
			remaining -= 1
		end

		-- Choose map
		local chosen = votes.Warehouse > votes.Supermarket and "Warehouse" or "Supermarket"
		StartRound:FireAllClients(chosen)

		local chosenFolder = Maps:FindFirstChild(chosen)
		if not chosenFolder then
			warn("Chosen map not found:", chosen)
			-- fallback to continue loop
			task.wait(1)
			continue
		end

		local mapModelSource = chosenFolder:FindFirstChildWhichIsA("Model")
		if not mapModelSource then
			warn("Map model missing inside folder:", chosen)
			task.wait(1)
			continue
		end

		local mapModel = mapModelSource:Clone()
		mapModel.Name = "ActiveMap"
		mapModel.Parent = Workspace

		local roundPlayers = getActivePlayers() -- players at round start

		-- Reset votes for next round
		votes.Supermarket = 0
		votes.Warehouse = 0
		playerVotes = {}

		-- assign shopping lists etc (unchanged, using your functions)
		local function assignShoppingList(players, config)
			for _, player in ipairs(players) do
				local oldInv = player:FindFirstChild("Inventory")
				if oldInv then oldInv:Destroy() end
				local oldList = player:FindFirstChild("ShoppingList")
				if oldList then oldList:Destroy() end

				local inv = Instance.new("Folder")
				inv.Name = "Inventory"
				inv.Parent = player

				local list = Instance.new("Folder")
				list.Name = "ShoppingList"
				list.Parent = player

				local count = 10
				local availableItems = {}
				for _, item in ipairs(config.Items) do
					table.insert(availableItems, item)
				end

				for i = 1, count do
					if #availableItems == 0 then break end
					local idx = math.random(1, #availableItems)
					local itemName = availableItems[idx]
					table.remove(availableItems, idx)

					local tag = Instance.new("StringValue")
					tag.Name = itemName
					tag.Parent = list
				end
			end
		end

		local function getMapConfig(mapModel, chosen)
			local configModule = require(ReplicatedStorage.MapConfigs[chosen])
			local spawns = mapModel:WaitForChild("ItemSpawns")

			for _, rowName in ipairs(configModule.RowNames) do
				if spawns:FindFirstChild(rowName.."Row") then
					configModule.Rows[rowName] = spawns[rowName.."Row"]:GetChildren()
				else
					warn("Missing spawn row folder:", rowName.."Row")
				end
			end
			return configModule
		end

		local function spawnItems(mapModel, config)
			local spawnedItemsFolder = mapModel:WaitForChild("ItemsFolder")
			for i = 1, config.ItemCount do
				local rowName = config.RowNames[math.random(1, #config.RowNames)]
				local row = config.Rows[rowName]
				local spawnPoint = row[math.random(1, #row)]
				local itemName = config.Items[math.random(1, #config.Items)]
				local itemFolder = ReplicatedStorage:WaitForChild(config.ItemFolder)
				local model = itemFolder:FindFirstChild(itemName):Clone()
				model.Parent = spawnedItemsFolder

				local validPosition = false
				local tryCount = 0
				local finalCF
				while not validPosition and tryCount < 10 do
					tryCount += 1
					local size = spawnPoint.Size
					local offsetX = (math.random()-0.5)*size.X
					local offsetZ = (math.random()-0.5)*size.Z
					local baseCF = spawnPoint.CFrame
					local randomCF = baseCF * CFrame.new(offsetX,0,offsetZ)
					local itemHeight = (model:GetExtentsSize().Y/2)+(spawnPoint.Size.Y/2)
					local aboveCF = randomCF * CFrame.new(0,itemHeight,0)

					local rotationCF
					local _, yRot, _ = spawnPoint.CFrame:ToEulerAnglesYXZ()
					if config.RotationMode == "SupermarketRotation" then
						rotationCF = CFrame.Angles(0, yRot, 0)
					elseif config.RotationMode == "WarehouseRotation" then
						rotationCF = CFrame.Angles(math.rad(-90), math.rad(-180), 0)
					end

					finalCF = CFrame.new(aboveCF.Position) * rotationCF

					local overlaps = false
					local modelSize = model:GetExtentsSize()
					for _, other in ipairs(spawnedItemsFolder:GetChildren()) do
						if other ~= model and other:IsA("Model") then
							local otherSize = other:GetExtentsSize()
							local dist = (other:GetPivot().Position - finalCF.Position).Magnitude
							local minAllowed = (modelSize.Magnitude + otherSize.Magnitude)/4
							if dist < minAllowed then
								overlaps = true
								break
							end
						end
					end
					if not overlaps then validPosition = true end
				end

				model:PivotTo(finalCF)
			end
		end

		-- Start round processes
		local config = getMapConfig(mapModel, chosen)
		spawnItems(mapModel, config)
		assignShoppingList(getActivePlayers(), config) -- give to active players (re-evaluated)
		teleportPlayersToMap(mapModel)

		-- Stop lobby song safely
		if hanabi then pcall(function() hanabi:Stop() end) end

		-- choose & play round song
		local currentSong = (math.random(1, 2) == 1) and profundoMarAzul or sun
		if currentSong then pcall(function() currentSong:Play() end) end

		local playerCompletionTime = {}
		local roundEnded = false
		local elapsed = 0

		-- Round timer loop (ends early if not enough players)
		while elapsed < roundTime and not roundEnded do
			-- If active players drop below 2, end the round early
			if #getActivePlayers() < 2 then
				-- Notify clients and cleanup
				-- You may prefer to pause instead of ending; change behavior here if desired
				EndRound:FireAllClients() -- inform clients
				cleanupActiveMap()
				teleportPlayersToLobby()
				roundEnded = true
				break
			end

			RoundTimeUpdate:FireAllClients(roundTime - elapsed)
			task.wait(1)
			elapsed += 1

			-- Ensure everyone has a shopping list if they're active
			for _, player in ipairs(getActivePlayers()) do
				local afk = player:FindFirstChild("AFK")
				if afk and afk.Value then continue end
				if not player:FindFirstChild("ShoppingList") then
					assignShoppingList({player}, config)
				end
			end

			-- Check for completion
			for _, player in ipairs(getActivePlayers()) do
				local afk = player:FindFirstChild("AFK")
				if afk and afk.Value then continue end
				local list = player:FindFirstChild("ShoppingList")
				if list and #list:GetChildren() == 0 and not playerCompletionTime[player] then
					playerCompletionTime[player] = elapsed

					-- One player completed, end round
					EndRound:FireAllClients(player.Name)
					cleanupActiveMap()
					teleportPlayersToLobby()
					roundEnded = true
					break
				end
			end
		end

		-- If round ended normally (not early by single winner path), handle winners / results
		if not next(playerCompletionTime) then
			-- No winners: DNF
			for _, player in ipairs(getActivePlayers()) do
				local list = player:FindFirstChild("ShoppingList")
				if list and #list:GetChildren() > 0 then
					playerCompletionTime[player.Name] = "DNF"
				end
			end

			EndRound:FireAllClients()
		else
			-- compute winners (fastest times)
			local winners = {}
			local fastestTime = math.huge
			for player, time in pairs(playerCompletionTime) do
				if typeof(time) == "number" and time < fastestTime then
					fastestTime = time
					winners = {player}
				elseif typeof(time) == "number" and time == fastestTime then
					table.insert(winners, player)
				end
			end

			if #winners > 0 then
				-- award winners
				for _, player in ipairs(winners) do
					local leaderstats = player:FindFirstChild("leaderstats")
					local boosts = player:FindFirstChild("Boosts")
					local x2Tokens = boosts and boosts:FindFirstChild("x2Tokens")
					if leaderstats then
						local wins = leaderstats:FindFirstChild("Wins")
						local tokens = leaderstats:FindFirstChild("Tokens")
						if wins then wins.Value += 1 end
						if tokens then
							tokens.Value += math.random(1,5)
							if x2Tokens and x2Tokens.Value > 0 then
								tokens.Value += math.random(5,10)
							end
						end
					end
				end

				local winnerNames = {}
				for _, player in ipairs(winners) do
					table.insert(winnerNames, player.Name)
				end
				EndRound:FireAllClients(unpack(winnerNames))
			else
				-- no winners; DNF handling already done earlier
				EndRound:FireAllClients()
			end
		end

		-- Final cleanup & restore lobby
		cleanupActiveMap()
		if currentSong then pcall(function() currentSong:Stop() end) end
		if hanabi then pcall(function() hanabi:Play() end) end

		teleportPlayersToLobby()
		RoundResults:FireAllClients(playerCompletionTime)
	end
end)
